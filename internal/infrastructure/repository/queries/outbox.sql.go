// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: outbox.sql

package db_queries

import (
	"context"

	"github.com/google/uuid"
)

const createOutboxMessage = `-- name: CreateOutboxMessage :exec


INSERT INTO outbox (
    key,
    value,
    topic
) VALUES (
    $1, $2, $3
)
`

type CreateOutboxMessageParams struct {
	Key   uuid.UUID
	Value []byte
	Topic string
}

// outbox.sql
func (q *Queries) CreateOutboxMessage(ctx context.Context, arg CreateOutboxMessageParams) error {
	_, err := q.db.Exec(ctx, createOutboxMessage, arg.Key, arg.Value, arg.Topic)
	return err
}

type CreateOutboxMessagesParams struct {
	Key   uuid.UUID
	Value []byte
	Topic string
}

const readOutboxMessages = `-- name: ReadOutboxMessages :many
WITH messages AS (
    SELECT 
        id, 
        key, 
        value, 
        topic
    FROM 
        outbox o
    WHERE 
        o.topic = $1
        AND o.is_read = FALSE
        AND o.deleted_at IS NULL
    ORDER BY o.created_at
    LIMIT $2
)
UPDATE 
    outbox
SET 
    is_read = TRUE
FROM 
    messages m
WHERE 
    outbox.id = m.id
RETURNING 
    m.key, 
    m.value, 
    m.topic
`

type ReadOutboxMessagesParams struct {
	Topic string
	Limit int32
}

type ReadOutboxMessagesRow struct {
	Key   uuid.UUID
	Value []byte
	Topic string
}

func (q *Queries) ReadOutboxMessages(ctx context.Context, arg ReadOutboxMessagesParams) ([]ReadOutboxMessagesRow, error) {
	rows, err := q.db.Query(ctx, readOutboxMessages, arg.Topic, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReadOutboxMessagesRow{}
	for rows.Next() {
		var i ReadOutboxMessagesRow
		if err := rows.Scan(&i.Key, &i.Value, &i.Topic); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
