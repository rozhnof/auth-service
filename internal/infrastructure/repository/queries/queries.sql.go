// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db_queries

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createOrUpdateRefreshToken = `-- name: CreateOrUpdateRefreshToken :exec
WITH updated AS (
    UPDATE refresh_token
    SET deleted_at = NOW()
    WHERE user_id = $1
      AND refresh_token != $2
      AND deleted_at IS NULL
    RETURNING id, user_id, refresh_token, expired_at, deleted_at
)
INSERT INTO refresh_token (
    user_id, 
    refresh_token, 
    expired_at
)
VALUES ($1, $2, $3)
ON CONFLICT (refresh_token) DO NOTHING
`

type CreateOrUpdateRefreshTokenParams struct {
	UserID       uuid.UUID
	RefreshToken string
	ExpiredAt    time.Time
}

func (q *Queries) CreateOrUpdateRefreshToken(ctx context.Context, arg CreateOrUpdateRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, createOrUpdateRefreshToken, arg.UserID, arg.RefreshToken, arg.ExpiredAt)
	return err
}

const createOutboxMessage = `-- name: CreateOutboxMessage :exec
INSERT INTO outbox (
    key,
    value,
    topic
) VALUES (
    $1, $2, $3
)
`

type CreateOutboxMessageParams struct {
	Key   uuid.UUID
	Value []byte
	Topic string
}

func (q *Queries) CreateOutboxMessage(ctx context.Context, arg CreateOutboxMessageParams) error {
	_, err := q.db.Exec(ctx, createOutboxMessage, arg.Key, arg.Value, arg.Topic)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (
    id,
    email,
    hash_password
) VALUES (
    $1, $2, $3
)
`

type CreateUserParams struct {
	ID           uuid.UUID
	Email        string
	HashPassword string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.ID, arg.Email, arg.HashPassword)
	return err
}

const deleteRefreshTokenByUserID = `-- name: DeleteRefreshTokenByUserID :exec
UPDATE 
    refresh_token
SET 
    deleted_at = COALESCE(deleted_at, NOW())
WHERE 
    user_id = $1
`

func (q *Queries) DeleteRefreshTokenByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRefreshTokenByUserID, userID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE 
    users
SET 
    deleted_at = COALESCE(deleted_at, NOW())
WHERE 
    id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT 
    u.id, u.email, u.hash_password, u.deleted_at,
    rt.id AS refresh_token_id,
    rt.refresh_token AS refresh_token,
    rt.expired_at AS refresh_token_expired_at
FROM 
    users u
LEFT JOIN 
    refresh_token rt ON u.id = rt.user_id
WHERE 
    u.email = $1
    AND u.deleted_at IS NULL
    AND rt.deleted_at IS NULL
`

type GetUserByEmailRow struct {
	User                  User
	RefreshTokenID        *uuid.UUID
	RefreshToken          *string
	RefreshTokenExpiredAt *time.Time
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.User.ID,
		&i.User.Email,
		&i.User.HashPassword,
		&i.User.DeletedAt,
		&i.RefreshTokenID,
		&i.RefreshToken,
		&i.RefreshTokenExpiredAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one


SELECT 
    u.id, u.email, u.hash_password, u.deleted_at,
    rt.id AS refresh_token_id,
    rt.refresh_token AS refresh_token,
    rt.expired_at AS refresh_token_expired_at
FROM 
    users u
LEFT JOIN 
    refresh_token rt ON u.id = rt.user_id
WHERE 
    u.id = $1
    AND u.deleted_at IS NULL
    AND rt.deleted_at IS NULL
`

type GetUserByIDRow struct {
	User                  User
	RefreshTokenID        *uuid.UUID
	RefreshToken          *string
	RefreshTokenExpiredAt *time.Time
}

// queries.sql
func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.User.ID,
		&i.User.Email,
		&i.User.HashPassword,
		&i.User.DeletedAt,
		&i.RefreshTokenID,
		&i.RefreshToken,
		&i.RefreshTokenExpiredAt,
	)
	return i, err
}

const getUserByRefreshToken = `-- name: GetUserByRefreshToken :one
SELECT 
    u.id, u.email, u.hash_password, u.deleted_at,
    rt.id AS refresh_token_id,
    rt.refresh_token AS refresh_token,
    rt.expired_at AS refresh_token_expired_at
FROM 
    users u
LEFT JOIN 
    refresh_token rt ON u.id = rt.user_id
WHERE 
    rt.refresh_token = $1
    AND u.deleted_at IS NULL
    AND rt.deleted_at IS NULL
`

type GetUserByRefreshTokenRow struct {
	User                  User
	RefreshTokenID        *uuid.UUID
	RefreshToken          *string
	RefreshTokenExpiredAt *time.Time
}

func (q *Queries) GetUserByRefreshToken(ctx context.Context, refreshToken string) (GetUserByRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserByRefreshToken, refreshToken)
	var i GetUserByRefreshTokenRow
	err := row.Scan(
		&i.User.ID,
		&i.User.Email,
		&i.User.HashPassword,
		&i.User.DeletedAt,
		&i.RefreshTokenID,
		&i.RefreshToken,
		&i.RefreshTokenExpiredAt,
	)
	return i, err
}

const listUser = `-- name: ListUser :many
SELECT 
    u.id, u.email, u.hash_password, u.deleted_at,
    rt.id AS refresh_token_id,
    rt.refresh_token AS refresh_token,
    rt.expired_at AS refresh_token_expired_at
FROM 
    users u
LEFT JOIN 
    refresh_token rt ON u.id = rt.user_id
WHERE 
    ($1::UUID[] IS NULL OR u.id = ANY($1::UUID[]))
    AND u.deleted_at IS NULL
    AND rt.deleted_at IS NULL
LIMIT $3
OFFSET $2
`

type ListUserParams struct {
	UserIds []uuid.UUID
	Offset  int32
	Limit   *int32
}

type ListUserRow struct {
	User                  User
	RefreshTokenID        *uuid.UUID
	RefreshToken          *string
	RefreshTokenExpiredAt *time.Time
}

func (q *Queries) ListUser(ctx context.Context, arg ListUserParams) ([]ListUserRow, error) {
	rows, err := q.db.Query(ctx, listUser, arg.UserIds, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserRow{}
	for rows.Next() {
		var i ListUserRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Email,
			&i.User.HashPassword,
			&i.User.DeletedAt,
			&i.RefreshTokenID,
			&i.RefreshToken,
			&i.RefreshTokenExpiredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readOutboxMessageList = `-- name: ReadOutboxMessageList :many
WITH messages AS (
    SELECT 
        id, 
        key, 
        value, 
        topic
    FROM 
        outbox o
    WHERE 
        o.topic = $1
        AND o.is_read = FALSE
        AND o.deleted_at IS NULL
    ORDER BY o.created_at
    LIMIT $2
)
UPDATE 
    outbox
SET 
    is_read = TRUE
FROM 
    messages m
WHERE 
    outbox.id = m.id
RETURNING 
    m.key, 
    m.value, 
    m.topic
`

type ReadOutboxMessageListParams struct {
	Topic string
	Limit int32
}

type ReadOutboxMessageListRow struct {
	Key   uuid.UUID
	Value []byte
	Topic string
}

func (q *Queries) ReadOutboxMessageList(ctx context.Context, arg ReadOutboxMessageListParams) ([]ReadOutboxMessageListRow, error) {
	rows, err := q.db.Query(ctx, readOutboxMessageList, arg.Topic, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReadOutboxMessageListRow{}
	for rows.Next() {
		var i ReadOutboxMessageListRow
		if err := rows.Scan(&i.Key, &i.Value, &i.Topic); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :exec
UPDATE 
    users
SET  
    email = $2,
    hash_password = $3
WHERE 
    users.id = $1
`

type UpdateUserParams struct {
	ID           uuid.UUID
	Email        string
	HashPassword string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.ID, arg.Email, arg.HashPassword)
	return err
}
